from typing import List, Tuple


def _bin4(x: int) -> str:
    """
    Перевод числа в двоичную систему
        :param x: Число для перевода
        :return: Число в двоичной системе, дополненное нулями до длины 4
    """
    if not (0 <= x <= 15):
        raise ValueError("Символ вне диапазона 0..15")
    return format(x, "04b")


def _bits_to_int(bits: str) -> int:
    """
    Переводит число из двоичной системе в десятичную
    :param bits: Число для перевода
    :return: Выводимое число
    """
    return int(bits, 2)


class HammingCoder74:
    """
    Код Хэмминга (7,4) для кодирования и декодирования данных с исправлением ошибок.
    Кодирует 4 бита данных в 7-битное слово с возможностью исправления одной ошибки.
    """

    # Проверочная матрица R для вычисления проверочных битов
    # Размер: 4x3 (4 информационных бита × 3 проверочных бита)
    R = [
        [1, 1, 1],  # Правила формирования проверочных битов для 1-го информационного бита
        [1, 0, 1],  # Правила формирования проверочных битов для 2-го информационного бита
        [1, 1, 0],  # Правила формирования проверочных битов для 3-го информационного бита
        [0, 1, 1],  # Правила формирования проверочных битов для 4-го информационного бита
    ]

    # Столбцы проверочной матрицы H (матрица паритета)
    # Каждый столбец соответствует позиции бита в кодовом слове (1-7)
    H_cols = [
        [1, 1, 1],  # Столбец для 1-го бита (информационный)
        [1, 0, 1],  # Столбец для 2-го бита (информационный)
        [1, 1, 0],  # Столбец для 3-го бита (информационный)
        [0, 1, 1],  # Столбец для 4-го бита (информационный)
        [1, 0, 0],  # Столбец для 5-го бита (проверочный) - единичная матрица
        [0, 1, 0],  # Столбец для 6-го бита (проверочный) - единичная матрица
        [0, 0, 1],  # Столбец для 7-го бита (проверочный) - единичная матрица
    ]


    def _mul_u_R(self, u_bits: str) -> str:
        """
        Умножение информационного вектора на матрицу R для получения проверочных битов.
        :param u_bits: 4-битная строка с информационными битами
        :return: 3-битная строка с проверочными битами
        """
        u = [int(b) for b in u_bits]  # Преобразуем строку в список чисел
        p = []  # Список для проверочных битов

        # Вычисляем каждый проверочный бит
        for j in range(3):  # Для каждого из 3 проверочных битов
            s = 0  # Накопитель для XOR-операций
            for i in range(4):  # Для каждого из 4 информационных битов
                # XOR-умножение бита данных на соответствующий элемент матрицы R
                s ^= (u[i] & self.R[i][j])
            p.append(str(s))  # Добавляем вычисленный проверочный бит

        return "".join(p)  # Возвращаем проверочные биты как строку

    def _syndrome(self, v_bits: str) -> str:
        """
        Вычисление синдрома для полученного кодового слова.
        Синдром показывает наличие и позицию ошибки.
            :param v_bits: 7-битное полученное кодовое слово
            :return: 3-битный синдром (строка)
        """
        v = [int(b) for b in v_bits]  # Преобразуем строку в список чисел
        s = [0, 0, 0]  # Инициализируем синдром [0,0,0]

        # Вычисляем синдром как сумму столбцов, где есть единицы
        for idx, bit in enumerate(v):
            if bit:  # Если бит равен 1
                c = self.H_cols[idx]  # Берем соответствующий столбец матрицы H
                # Выполняем XOR между текущим синдромом и столбцом матрицы
                s = [(s[k] ^ c[k]) for k in range(3)]

        return "".join(str(x) for x in s)  # Возвращаем синдром как строку

    def encode_symbol(self, x: int) -> str:
        """
        Кодирование одного символа (числа 0-15) в 7-битное кодовое слово Хэмминга.
            :param x: Число от 0 до 15 для кодирования
            :return: 7-битная строка с закодированным словом
        """
        u = _bin4(x)          # Преобразуем число в 4 информационных бита
        p = self._mul_u_R(u)  # Вычисляем 3 проверочных бита
        return u + p          # Возвращаем систематическое кодовое слово (данные + проверочные)

    def encode(self, symbols: List[int]) -> str:
        """
        Кодирование списка символов в битовую строку.
            :param symbols: Список чисел от 0 до 15
            :return: Битовая строка с закодированными данными
        """
        return "".join(self.encode_symbol(x) for x in symbols)

    def decode_word(self, word7: str) -> Tuple[int, str, int, str]:
        """
        Декодирование одного 7-битного слова с исправлением ошибок.
            :param word7: 7-битное кодовое слово для декодирования
            :return: Кортеж (декодированное число, исправленное слово, позиция ошибки, синдром)
        """
        # Проверка корректности входных данных
        if len(word7) != 7 or any(b not in "01" for b in word7):
            raise ValueError("Ожидается 7-битное слово из 0/1")

        # Вычисляем синдром для обнаружения ошибок
        s = self._syndrome(word7)
        corrected = list(word7)  # Создаем копию слова для возможного исправления
        pos = 0  # Позиция ошибки (0 - ошибок нет)

        # Если синдром не нулевой - есть ошибка
        if s != "000":
            # Ищем столбец в H, соответствующий синдрому
            for i, col in enumerate(self.H_cols, start=1):
                if "".join(str(x) for x in col) == s:
                    pos = i  # Найденная позиция ошибки (1-7)
                    # Исправляем ошибочный бит (инвертируем)
                    corrected[i-1] = '0' if corrected[i-1] == '1' else '1'
                    break

        corr_word = "".join(corrected)  # Преобразуем обратно в строку
        u = corr_word[:4]  # Извлекаем информационные биты

        # Возвращаем результат декодирования
        return _bits_to_int(u), corr_word, pos, s

    def decode(self, bitstream: str) -> Tuple[List[int], List[dict]]:
        """
        Декодирование всей битовой строки с генерацией отчета.
            :param bitstream: Битовая строка длиной, кратной 7
            :return: Кортеж (список декодированных чисел, список отчетов по каждому слову)
        """
        # Проверка, что длина потока кратна 7
        if len(bitstream) % 7 != 0:
            raise ValueError("Длина потока должна быть кратна 7")

        symbols = []  # Список декодированных символов
        reports = []  # Список отчетов о декодировании

        # Обрабатываем поток по 7 бит
        for k in range(0, len(bitstream), 7):
            w = bitstream[k:k+7]  # Извлекаем 7-битное слово
            # Декодируем слово с исправлением ошибок
            sym, corr, pos, s = self.decode_word(w)
            symbols.append(sym)  # Добавляем декодированный символ
            # Формируем отчет по текущему слову
            reports.append({
                "start": k,           # Начальная позиция слова в потоке
                "end": k+7,           # Конечная позиция слова в потоке
                "syndrome": s,        # Вычисленный синдром
                "error_pos": pos,     # Позиция исправленной ошибки (0 если нет ошибок)
                "was_corrected": pos != 0  # Флаг исправления ошибки
            })

        return symbols, reports
